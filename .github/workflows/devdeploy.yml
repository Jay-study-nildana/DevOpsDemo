# I have left plenty of comments at the end of this file for you to note down for your first devops deployment

name: Develop Branch Build Test Deploy # The name of the workflow as it appears in GitHub Actions UI

on: # Specifies the events that trigger this workflow
  push: # Trigger when code is pushed to the repository
    branches:
      - develop     # Trigger only on pushes (including merges) to the develop branch

jobs: # Defines the jobs that will run as part of this workflow
  build: # The name of the job
    runs-on: ubuntu-latest # The job will run on the latest available Ubuntu runner

    steps: # The sequence of steps to execute in the job
      - name: Checkout code # Step 1: Checks out the repository code so it can be used by subsequent steps
        uses: actions/checkout@v3 # Uses the official GitHub Action for checking out code

      - name: Setup .NET # Step 2: Sets up the .NET SDK on the runner
        uses: actions/setup-dotnet@v3 # Uses the official GitHub Action for setting up .NET
        with:
          dotnet-version: '8.0.x' # Specifies the version of .NET SDK to install (8.0.x means any 8.0 version)

      - name: Restore dependencies # Step 3: Restores NuGet packages required by the project
        run: dotnet restore BackEndAPI/BackEndAPI.sln # Specify the solution path

      - name: Build # Step 4: Builds the project in Release configuration
        run: dotnet build BackEndAPI/BackEndAPI.sln --no-restore --configuration Release # Specify the solution path

      - name: Test # Step 5: Runs unit tests for the project
        run: dotnet test BackEndAPI/BackEndAPI.sln --no-build --configuration Release --verbosity normal # Specify the solution path

      - name: Publish # Step 6: Publishes the build output to a folder (optional step, can be used for deployment)
        run: dotnet publish BackEndAPI/BackEndAPI.sln --configuration Release --output ./published # Specify the solution path

      # Add steps to upload artifacts if needed for deployment
      # For example, you can use 'actions/upload-artifact' to save build outputs for later use

      - name: Azure Login # Step 7: Authenticates to Azure using Service Principal credentials
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # - name: Zip published output # Step: Compress the published folder for Azure deployment
      #   run: zip -r published.zip ./published    
      # this type of zipping is putting files in a folder called published which is not what we want

      - name: Zip published output # Compress contents for Azure deployment
        run: cd published && zip -r ../published.zip . && cd ..      

      - name: List contents of published.zip # Step: Inspect the ZIP file before deployment
        run: unzip -l published.zip              

      - name: Deploy to Azure Web App using Azure CLI # Step: Deploy the zipped output
        run: |
          az webapp deploy --resource-group rgaugust15th2025 --name devwebappaugust152025 --src-path published.zip

####################################################################################################
# Comparison of Azure Web App Deployment Methods in GitHub Actions
#
# 1. Publish Profile Method:
#    - Uses the azure/webapps-deploy GitHub Action.
#    - Requires downloading the publish profile XML from the Azure Portal and storing it as a GitHub secret.
#    - Simple to set up for most web app deployments.
#    - Limited to web app deployments and less flexible for advanced automation or multi-resource scenarios.
#
# 2. Service Principal + Azure CLI Method (Chosen Approach):
#    - Uses a Service Principal for authentication via the azure/login action.
#    - Deploys using Azure CLI commands (e.g., az webapp deploy).
#    - More flexible and secure for automation, especially in enterprise or multi-resource environments.
#    - Allows integration with other Azure resources and advanced deployment scenarios.
#
# Reason for Choosing Service Principal:
#    - Credentials are managed securely and can be reused for other Azure resources.
#    - Enables advanced deployment workflows and automation beyond simple web app publishing.
#    - Preferred for CI/CD pipelines in professional and enterprise settings.
####################################################################################################


####################################################################################################
# Notes on Mapping Azure CLI Service Principal Output to GitHub Actions Secret Format
#
# When using the azure/login GitHub Action for Service Principal authentication, the secret must be in a specific JSON format.
# The Azure CLI creates a service principal with output like this:
#
# Azure CLI Output Example:
# {
#   "appId": "<masked-appId>",
#   "displayName": "<masked-displayName>",
#   "password": "<masked-password>",
#   "tenant": "<masked-tenant>"
# }
#
# For GitHub Actions, you must remap these fields and add your Azure subscription ID:
#
# Expected GitHub Actions Secret Format:
# {
#   "clientId": "<masked-appId>",         # from appId
#   "clientSecret": "<masked-password>",  # from password
#   "tenantId": "<masked-tenant>",        # from tenant
#   "subscriptionId": "<masked-subscriptionId>" # your Azure subscription ID
# }
#
# Store this JSON as a GitHub secret (e.g., AZURE_CREDENTIALS) and reference it in your workflow using the 'creds' input.
####################################################################################################

####################################################################################################
# Notes on Build Output and Deployment Artifacts in GitHub Actions
#
# The 'dotnet publish' step creates a 'published' folder containing your build output.
# The 'zip -r published.zip ./published' step compresses this folder into a ZIP file.
#
# Both the 'published' folder and 'published.zip' exist only on the GitHub Actions runner
# (the temporary virtual machine that executes your workflow). They are not stored in your repository.
# These files are available only during the workflow run and are used for deployment or as artifacts.
####################################################################################################

####################################################################################################
# Notes on Accessing Azure Kudu (Advanced Tools) via Browser
#
# Sometimes, accessing the Kudu dashboard from Microsoft Edge can result in redirection errors or persistent popups,
# often due to stricter handling of authentication, cookies, or popups in Edge.
# As a best practice, use Google Chrome or Firefox for accessing Azure Kudu/Advanced Tools,
# as these browsers typically handle Azure authentication and redirects more reliably.
# If you must use Edge, ensure popups and third-party cookies are allowed, and try clearing your browser cache.
####################################################################################################

# ------------------------------------------------------------------------------------------
# IMPORTANT: Azure App Service Startup Command for ASP.NET Core Apps (Linux)
#
# - Azure App Service (Linux) expects your application's entry point (.dll) to be located
#   in the root of /home/site/wwwroot after deployment.
#
# - By default, Azure tries to auto-detect the startup file. If it cannot find your app's
#   DLL, it will run the default Azure app (hostingstart.dll), showing the "Azure Welcome" page.
#
# - To ensure your Web API runs correctly, explicitly set the Startup Command in the Azure Portal:
#     dotnet <YourAppName>.dll
#   Example:
#     dotnet BackEndAPI.dll
#
# - The Startup Command must match the name of your main .dll file as deployed.
#
# - If you still see the Azure startup page after deployment, it usually means:
#     - The DLL is not in the root folder
#     - The DLL name does not match your Startup Command
#     - The Startup Command is not set
#
# - Always verify:
#     - Your published files are in the correct location (/home/site/wwwroot)
#     - The correct runtime stack is selected in App Service settings
#     - The Startup Command matches your deployed .dll filename
#
# This comment summarizes common deployment issues and their solutions related to the Startup Command.
# ------------------------------------------------------------------------------------------