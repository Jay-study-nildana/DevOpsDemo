name: Develop Branch Build Test Deploy # The name of the workflow as it appears in GitHub Actions UI

on: # Specifies the events that trigger this workflow
  push: # Trigger when code is pushed to the repository
    branches:
      - develop     # Trigger only on pushes (including merges) to the develop branch

jobs: # Defines the jobs that will run as part of this workflow
  build: # The name of the job
    runs-on: ubuntu-latest # The job will run on the latest available Ubuntu runner

    steps: # The sequence of steps to execute in the job
      - name: Checkout code # Step 1: Checks out the repository code so it can be used by subsequent steps
        uses: actions/checkout@v3 # Uses the official GitHub Action for checking out code

      - name: Setup .NET # Step 2: Sets up the .NET SDK on the runner
        uses: actions/setup-dotnet@v3 # Uses the official GitHub Action for setting up .NET
        with:
          dotnet-version: '8.0.x' # Specifies the version of .NET SDK to install (8.0.x means any 8.0 version)

      - name: Restore dependencies # Step 3: Restores NuGet packages required by the project
        run: dotnet restore BackEndAPI/BackEndAPI.sln # Specify the solution path

      - name: Build # Step 4: Builds the project in Release configuration
        run: dotnet build BackEndAPI/BackEndAPI.sln --no-restore --configuration Release # Specify the solution path

      - name: Test # Step 5: Runs unit tests for the project
        run: dotnet test BackEndAPI/BackEndAPI.sln --no-build --configuration Release --verbosity normal # Specify the solution path

      - name: Publish (optional) # Step 6: Publishes the build output to a folder (optional step, can be used for deployment)
        run: dotnet publish BackEndAPI/BackEndAPI.sln --configuration Release --output ./published # Specify the solution path

      # Add steps to upload artifacts if needed for deployment
      # For example, you can use 'actions/upload-artifact' to save build outputs for later use

      - name: Azure Login # Step 7: Authenticates to Azure using Service Principal credentials
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy to Azure Web App using Azure CLI # Step 8: Deploys the published output using Azure CLI best practices
        run: |
          az webapp deploy --resource-group rgaugust15th2025 --name devwebappaugust152025 --src-path ./published

####################################################################################################
# Comparison of Azure Web App Deployment Methods in GitHub Actions
#
# 1. Publish Profile Method:
#    - Uses the azure/webapps-deploy GitHub Action.
#    - Requires downloading the publish profile XML from the Azure Portal and storing it as a GitHub secret.
#    - Simple to set up for most web app deployments.
#    - Limited to web app deployments and less flexible for advanced automation or multi-resource scenarios.
#
# 2. Service Principal + Azure CLI Method (Chosen Approach):
#    - Uses a Service Principal for authentication via the azure/login action.
#    - Deploys using Azure CLI commands (e.g., az webapp deploy).
#    - More flexible and secure for automation, especially in enterprise or multi-resource environments.
#    - Allows integration with other Azure resources and advanced deployment scenarios.
#
# Reason for Choosing Service Principal:
#    - Credentials are managed securely and can be reused for other Azure resources.
#    - Enables advanced deployment workflows and automation beyond simple web app publishing.
#    - Preferred for CI/CD pipelines in professional and enterprise settings.
####################################################################################################